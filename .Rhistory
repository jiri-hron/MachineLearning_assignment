model.pca.projected$PC1
ttt = model.pca$rotation
ttt
ttt$PC1
ttt
class(ttt)
ttt = data.frame(ttt)
colnames(ttt)
ttt$PC1
ttt = as.data.frame(model.pca$rotation)
ttt
ttt[order(abs(ttt$PC1)),]$PC1
ttt[order(abs(ttt$PC1), decreasing = TRUE),]$PC1
ttt[order(abs(ttt$PC1), decreasing = TRUE),]
ttt[order(abs(ttt$PC1), decreasing = TRUE),][,"PC1"]
ttt[order(abs(ttt$PC1), decreasing = TRUE),][, 1:3]
head(ttt[order(abs(ttt$PC1), decreasing = TRUE),][, 1:3], 1)
head(ttt[order(abs(ttt$PC1), decreasing = TRUE),][, 1:3], 10)
fit.svm
if(!(require(doParallel))) {
stop("install doParallel package")
}
## setup for model
set.seed(1324)
seeds <- vector(mode = "list", length = 11)
for(i in 1:10) {
#   seeds[[i]] = sample.int(n=1000, 3)
seeds[[i]] = sample.int(n=1000, 13)
}
seeds[[11]] = sample.int(n=1000, 1)
cv.trainControl = trainControl(method = "adaptive_cv",
number = 10,
verboseIter = TRUE,
index = createFolds(y = model.pca.projected$classe),
seeds = seeds,
savePredictions = TRUE,
allowParallel = TRUE)
## run model in parallel
cl = makeCluster(detectCores())
registerDoParallel(cl)
grid = data.frame(C = c(0.1, 1, 3, 5, 10, 15, 20, 30, 35, 40, 45, 50, 60))
fit.svm.cv = train(classe ~ .,
data = model.pca.projected,
method = "svmRadialCost",
trControl = cv.trainControl,
tuneGrid = grid)
library(caret)
cv.trainControl = trainControl(method = "adaptive_cv",
number = 10,
verboseIter = TRUE,
index = createFolds(y = model.pca.projected$classe),
seeds = seeds,
savePredictions = TRUE,
allowParallel = TRUE)
grid = data.frame(C = c(0.1, 1, 3, 5, 10, 15, 20, 30, 35, 40, 45, 50, 60))
fit.svm.cv = train(classe ~ .,
data = model.pca.projected,
method = "svmRadialCost",
trControl = cv.trainControl,
tuneGrid = grid)
fit.svm = fit.svm.cv
1 + 1`
`
1+ 1`
`
1-1-
`
23
43o
123]safd
`
1+1
model.pca.prcomp = as.data.frame(model.pca$rotation)
with(model.pca.prcomp,
head(model.pca.prcomp[order(abs(PC1), decreasing = TRUE),][, 1:3]), 10)
model.pca
summary(model.pca)
model.pca$bc
model.pca$std
model.pca$k
ttt = fit.svm$finalModel
names(ttt)
summary(ttt)
ttt
attr(*, ttt)
attr(ttt)
ttt
plot(ttt)
testing.model = testing[,!(colnames(testing) %in% "classe")]
testing.scaled = predict(model.scale, testing.model)
testing.pca = predict(model.pca, testing.scaled)
confusionMatrix(testing$classe, predict(fit.svm, testing.pca))
set.seed(1123)
proportionTrain = .75
inTrain = createDataPartition(y = data$classe,
p = proportionTrain,
list = FALSE)
training = data[inTrain,]
testing = data[-inTrain,]
## create objects used later by predictive algorithms and for plotting (pca)
model.mat = training[,!(colnames(training) %in% "classe")]
model.scale = preProcess(x = model.mat, method = c("center", "scale"))
model.normalized = predict(model.scale, model.mat)
model.pca = preProcess(x = model.normalized,
method = "pca",
thresh = 0.95)
model.pca.projected = predict(model.pca, model.normalized)
model.normalized$classe = training$classe
model.pca.projected$classe = training$classe
## create model for testing data
testing.model = testing[,!(colnames(testing) %in% "classe")]
testing.scaled = predict(model.scale, testing.model)
testing.pca = predict(model.pca, testing.scaled)
set.seed(1324)
seeds <- vector(mode = "list", length = 11)
for(i in 1:10) {
#   seeds[[i]] = sample.int(n=1000, 3)
seeds[[i]] = sample.int(n=1000, 13)
}
seeds[[11]] = sample.int(n=1000, 1)
cv.trainControl = trainControl(method = "adaptive_cv",
number = 10,
verboseIter = TRUE,
index = createFolds(y = model.pca.projected$classe),
seeds = seeds,
savePredictions = TRUE,
allowParallel = TRUE)
## run model in parallel
cl = makeCluster(detectCores())
registerDoParallel(cl)
source('~/.active-rstudio-document', echo=TRUE)
grid = data.frame(C = c(0.1, 1, 3, 5, 10, 15, 20, 30, 35, 40, 45, 50, 60))
fit.svm = train(classe ~ .,
data = model.pca.projected,
method = "svmRadialCost",
trControl = cv.trainControl,
tuneGrid = grid)
stopCluster(cl)
names(getModelInfo())
source('C:/Users/IBM_ADMIN/Desktop/education/academicworld/data_science/practical_ml/project/code/prepareTrainFunction.R')
getModelInfo("rrlda")
?rrlda
library("rrlda", lib.loc="~/R/win-library/3.0")
?train
cv.trainControl = prepareTrainFunction(3)
grid = data.frame(lambda = c(0.01, 0.1, 0.3, 1, 3, 6, 10, 20, 30),
hp = 0.75,
penalty = "L2")
fit.rrlda = train(classe ~ .,
data = model.pca.projected,
method = "rrlda",
trControl = cv.trainControl,
tuneGrid = grid)
cv.trainControl = prepareTrainFunction(9)
grid = data.frame(lambda = c(0.01, 0.1, 0.3, 1, 3, 6, 10, 20, 30),
hp = 0.75,
penalty = "L2")
fit.rrlda = train(classe ~ .,
data = model.pca.projected,
method = "rrlda",
trControl = cv.trainControl,
tuneGrid = grid)
cl = makeCluster(detectCores())
registerDoParallel(cl)
cv.trainControl = prepareTrainFunction(9)
grid = data.frame(lambda = c(0.01, 0.1, 0.3, 1, 3, 6, 10, 20, 30),
hp = 0.75,
penalty = "L2")
fit.rrlda = train(classe ~ .,
data = model.pca.projected,
method = "rrlda",
trControl = cv.trainControl,
tuneGrid = grid)
confusionMatrix(testing$classe, predict(fit.rrlda, testing.pca))
stopCluster(cl)
cv.trainControl = prepareTrainFunction(9)
args(cv.trainControl)
cv.trainControl
grid.rrlda = data.frame(lambda = c(0.01, 0.1, 0.3, 1, 3, 6, 10, 20, 30),
hp = 0.75,
penalty = "L2")
grid.svm = data.frame(C = c(0.1, 1, 3, 5, 10, 15, 20, 30, 35, 40, 45, 50, 60))
grid.rrlda
